var searchIndex = new Map(JSON.parse('[\
["kani",{"doc":"","t":"EYEHHCHHEEHCHQXCQXXXXCXEXXCXCEKMNXXXXPPFFGKHHNNNNNNNNNNNNNNMNNHNNNNNNNNNHHHHH","n":["Arbitrary","Arbitrary","RoundRobin","any","any_where","arbitrary","assert","assume","block_on","block_on_with_spawn","concrete_playback_run","contracts","cover","cover","ensures","futures","implies","proof","proof_for_contract","requires","should_panic","slice","solver","spawn","stub","stub_verified","tuple","unwind","vec","yield_now","Arbitrary","any","any_array","ensures","proof_for_contract","requires","stub_verified","CanAssumeRunning","CannotAssumeRunning","JoinHandle","RoundRobin","SchedulingAssumption","SchedulingStrategy","block_on","block_on_with_spawn","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","default","from","from","from","into","into","into","into_future","pick_task","pick_task","poll","spawn","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","yield_now","any_slice_of_array","any_slice_of_array_mut","any_vec","exact_vec"],"q":[[0,"kani"],[30,"kani::arbitrary"],[33,"kani::contracts"],[37,"kani::futures"],[73,"kani::slice"],[75,"kani::vec"],[77,"core::ops::function"],[78,"alloc::vec"],[79,"core::ops::function"],[80,"core::marker"],[81,"core::pin"],[82,"core::task::wake"],[83,"core::task::poll"],[84,"core::result"],[85,"core::any"]],"d":["","Allow users to auto generate Arbitrary implementations by …","","This creates an symbolic <em>valid</em> value of type <code>T</code>. You can …","This creates a symbolic <em>valid</em> value of type <code>T</code>. The value …","This module introduces the Arbitrary trait as well as …","Creates an assertion of the specified condition and …","Creates an assumption that will be valid after this …","","","NOP <code>concrete_playback</code> for type checking during …","Kani implementation of function contracts.","Creates a cover property with the specified condition and …","A macro to check if a condition is satisfiable at a …","Add a postcondition to this function.","This module contains functions to work with futures (and …","<code>implies!(premise =&gt; conclusion)</code> means that if the <code>premise</code> …","Marks a Kani proof harness","Designates this function as a harness to check a function …","Add a precondition to this function.","Specifies that a proof harness is expected to panic.**","","Select the SAT solver to use with CBMC for this harness","","Specify a function/method stub pair to use for proof …","<code>stub_verified(TARGET)</code> is a harness attribute (to be used on","Support for arbitrary tuples where each element implements …","Set Loop unwind limit for proof harnesses The attribute …","","","This trait should be used to generate symbolic variables …","","","Add a postcondition to this function.","Designates this function as a harness to check a function …","Add a precondition to this function.","<code>stub_verified(TARGET)</code> is a harness attribute (to be used on","","","Result of spawning a task.","Keeps cycling through the tasks in a deterministic order","Indicates to the scheduler whether it can <code>kani::assume</code> …","Trait that determines the possible sequence of tasks …","A very simple executor: it polls the future in a busy loop …","Polls the given future and the tasks it may spawn until …","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","Picks the next task to be scheduled whenever the scheduler …","","","Spawns a task on the current global executor (which is set …","","","","","","","","","","Suspends execution of the current future, to allow the …","Given an array <code>arr</code> of length <code>LENGTH</code>, this function returns …","A mutable version of the previous function","Generates an arbitrary vector whose length is at most …","Generates an arbitrary vector that is exactly EXACT_LENGTH …"],"i":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,16,16,0,0,0,0,0,0,16,17,14,16,17,14,14,16,17,14,16,17,14,17,13,14,17,0,16,17,14,16,17,14,16,17,14,0,0,0,0,0],"f":[0,0,0,[[],-1,1],[-2,-1,1,[[4,[-1],[[2,[3]]]]]],0,[[3,5],6],[3,6],0,0,[[[8,[[8,[7]]]],-1],6,9],0,[[3,5],6],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[],1],[[],[[10,[1]]]],0,0,0,0,0,0,0,0,0,0,[-2,-1,[],[[11,[],[[2,[-1]]]]]],[[-1,-2],6,[[11,[],[[2,[6]]]],12],13],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[],14],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[],[]],[[13,15],[[6,[15,16]]]],[[14,15],[[6,[15,16]]]],[[[18,[17]],19],[[20,[-1]]],[]],[-1,17,[[11,[],[[2,[6]]]],12]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,22,[]],[-1,22,[]],[-1,22,[]],[[],[[0,[[11,[],[[2,[6]]]]]]]],[[[10,[-1]]],[[23,[-1]]],[]],[[[10,[-1]]],[[23,[-1]]],[]],[[],[[8,[-1]]],1],[[],[[8,[-1]]],1]],"c":[],"p":[[10,"Arbitrary",30],[17,"Output"],[1,"bool"],[10,"FnOnce",77],[1,"str"],[1,"tuple"],[1,"u8"],[5,"Vec",78],[10,"Fn",77],[1,"array"],[10,"Future",79],[10,"Sync",80],[10,"SchedulingStrategy",37],[5,"RoundRobin",37],[1,"usize"],[6,"SchedulingAssumption",37],[5,"JoinHandle",37],[5,"Pin",81],[5,"Context",82],[6,"Poll",83],[6,"Result",84],[5,"TypeId",85],[1,"slice"]],"b":[]}]\
]'));
if (typeof exports !== 'undefined') exports.searchIndex = searchIndex;
else if (window.initSearch) window.initSearch(searchIndex);
